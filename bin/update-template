#!/usr/bin/env python

from copy import deepcopy
from subprocess import Popen, PIPE, check_call
import argparse
import os
import sys

from lxml.html import tostring
from pyquery import PyQuery

from dateutil.parser import parse as parse_date

from simple_cloud_site.files import find_blog_posts
from simple_cloud_site.html import parse_html, lxml_inner_html, extract_last_modified


def update_template(template_file, filename):
    # TODO: refactor to use site settings site-root function
    source_dir = os.path.realpath(os.curdir)
    all_posts = find_blog_posts(source_dir)

    template = PyQuery(parse_html(template_file).getroot())
    original = PyQuery(parse_html(filename).getroot())

    # TODO: Fix PyQuery attribute selectors:
    title = (original('*[@itemprop="title"]') + original('title')).eq(0).text().strip()
    template('title,*[itemprop="title"]').removeClass('placeholder').text(title)

    # TODO: Reconcile PyQuery/lxml overlap
    # TODO: Refactor date logic into a page class

    # TODO: Normalize timestamps!
    lastMod = original('*[itemprop="dateModified"]').attr('datetime') or \
              original('*[itemprop="datePublished"]').attr('datetime') or \
              original('*[itemprop="dateCreated"]').attr('datetime')

    lastMod = parse_date(lastMod) if lastMod else None

    for i in ('dateCreated', 'dateModified', 'datePublished'):
        j = original('*[itemprop="%s"]' % i)
        if j:
            template('*[itemprop="%s"]' % i).attr('datetime', j.attr('datetime'))

    if lastMod:
        template('.date').removeClass('placeholder') \
            .text(lastMod.strftime('%b %d')) \
            .attr("datetime", lastMod.isoformat())

    summary = original('.summary').eq(0)
    if summary:
        template('.summary').removeClass('placeholder').empty().html(summary.html())
    else:
        template('.summary').remove()

    template('.body').removeClass('placeholder') \
        .empty() \
        .append(original('*[itemprop="articleBody"]'))

    template('meta[name="description"]').attr('content', original('meta[name="description"]').attr('content') or summary.text() or "")

    # Clean bogon classes (see https://github.com/gawel/pyquery/issues/23)
    template('*[class=""]').removeAttr("class")

    orphans = template.find(".placeholder")
    if orphans:
        print("Template contained unexpanded placeholders:", orphans, file=sys.stderr)
        # return

    with open(filename, 'wb') as f:
        # We don't use template.outerHtml because that would lose the doctype
        f.write(tostring(template[0].getroottree(), method='html', encoding='utf-8'))

    # This is an ugly travesty and depends on https://github.com/w3c/tidy-html5
    # In its defense, it actually works at all which is more than can be said for html5lib, lxml3,
    # BeautifulSoup, etc. and there are no Python 3 migration issuesâ€¦
    tidy = Popen(['tidy-html5', '-utf8', '-modify', '-quiet', '--tidy-mark', 'no',
                  '--wrap', '0', '--indent', 'yes', '--indent-spaces', '4',
                  filename],
                  stderr=PIPE, stdout=PIPE)
    stdout, stderr = tidy.communicate()

    if stderr:
        stderr = stderr.decode("utf-8").strip()
        stderr = "\n".join("\t%s" % i.strip() for i in stderr.splitlines())
        print("HTML tidy reported problems for %s:\n" % filename, stderr, file=sys.stderr)

    check_call(['perl', '-p', '-i', '-e', 's|itemscope=""|itemscope|', filename])
    # See: https://github.com/w3c/tidy-html5/pull/58

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Apply a template to an HTML file')
    parser.add_argument('files', metavar="HTML", nargs="*")
    parser.add_argument('--template', default="_templates/post.html",
                       help='Template filename (default: %(default)s)')
    args = parser.parse_args()

    if not os.path.exists(args.template):
        parser.error("%s does not exist" % args.template)

    for f in args.files:
        update_template(args.template, f)
